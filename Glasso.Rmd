---
title: '1985-2016_new'
output: html_document
date: "2023-09-29"
---

Directory

```{r, setup, include=FALSE}

knitr::opts_knit$set(root.dir = "G:/Il mio Drive/Eugenia's Thesis/Data")

```

Loading data (log-return in %) from 1984 to 2016

```{r loading data}

sp500_CIK <- read.csv("SP500_new.csv")

```

Extracting years of interest and keeping only the stocks always present over those years

```{r clearing data}

start_year = 1985
end_year = 2016

data <- sp500_CIK[sp500_CIK$Year %in% (start_year:end_year),]

#vector of row coordinates of the first observation per year (1985-2015)
i <- c(1,253,506,759,1012,1264,1517,1770,2024,2278,2529,2781,3035,3288,3540,3792,4044,4292,4544,4796,5048,5300,5551,5802,6055,6307,6559,6811,7061,7313,7565)

#vector of row coordinates of the last observation per year (1986-2016)
j <- c(505,758,1011,1263,1516,1769,2023,2276,2528,2780,3034,3287,3539,3791,4043,4291,4543,4795,5047,5299,5550,5801,6054,6306,6558,6810,7060,7312,7564,7816,7895)

to_keep <- list() 
for (k in 1:length(j)){
  #we only keep companies that are present over 2 consecutive years
  to_keep[[k]] = apply(data[i[k]:j[k],],2,function(x) all(!is.na(x)))
}

Y <- list()
for (k in 1:length(j)){
  Y[[k]] = data[,to_keep[[k]]]
}

end_year = 2015 #last year the model is fitted in

Y_repeats = list()
k<-seq(from=1, to=length(j), by=1)
t<-seq(from=start_year, to=end_year, by=1)
#create a list in which each object corresponds to a year and it is a matrix n (number of days) x p (number of stocks)
for (k in 1:length(k)){
  Y_repeats[[k]] = Y[[k]][Y[[k]]$Year == t[k],-(1:2)]
}

```

EBIC evaluation functions

```{r functions, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE}

ebic_eval_GLASSO_unstandarised <- function(Y, res, n, beta0, ebic.gamma, edge.tol, tol){
  p <- ncol(Y)
  cov_Y <- cov(Y)
  K <- res$K
  S <- cor2cov(res$Sig, diag(cov_Y)) ## unstandardrised
  log_likelihood_norm <- sum(mvtnorm::dmvnorm(Y, mean = rep(0, p), sigma = S, log = TRUE))
  KR <- stats::cov2cor((K))   #to make edge count independend of scalings
  nedg <- length(which(abs(KR[upper.tri(abs(KR), diag = FALSE)]) > edge.tol))
  p <- ncol(Y)
  ebic <- -2*log_likelihood_norm  + nedg * (log(n) + 4 * ebic.gamma * log(p))
  return(ebic)  
}

ebic_eval <- function(n, R, U, ebic.gamma, edge.tol, tol){
  res <- golazo(R, L = -U, U = U, verbose = FALSE, tol = tol)
  K <- res$K
  KR <- stats::cov2cor(K)         #to make edge count independend of scalings
  nedg <- length(which(abs(KR[upper.tri(abs(KR), diag = FALSE)]) > edge.tol))
  p <- ncol(R)
  ebic <- -(n)*(log(det(K)) - sum(R*K)) + n*p*log(2*pi) + nedg * (log(n) + 4 * ebic.gamma * log(p))
  return(ebic)   
}

ebic_eval_network <- function(n, R, A, beta0, beta1, ebic.gamma, edge.tol, tol){
  U <- exp(beta0 + beta1*A)   
  diag(U) <- 0
  return(ebic_eval(n, R, U, ebic.gamma, edge.tol, tol))
}

ebic_eval_two_networks <- function(n, R, A1, A2, beta0, beta1, beta2, ebic.gamma, edge.tol, tol){
   U <- exp(beta0 + beta1*A1 + beta2*A2)  
   diag(U) <- 0
   return(ebic_eval(n, R, U, ebic.gamma, edge.tol, tol))
}

ebic_eval_BayesOpt <- function(n, R, beta0, ebic.gamma, edge.tol, tol){
  p <- nrow(R)
  U <- matrix(exp(beta0), nrow = p, ncol = p) 
  diag(U) <- 0
  ebic <- ebic_eval(n, R, U, ebic.gamma, edge.tol, tol)
  return(list("Score" = -ebic, "Pred" = 0))   
}

ebic_eval_network_BayesOpt <- function(n, R, A, beta0, beta1, ebic.gamma, edge.tol, tol){
  U <- exp(beta0 + beta1*A)           #### remember a = beta1, b= beta0
  diag(U) <- 0
  ebic <- ebic_eval(n, R, U, ebic.gamma, edge.tol, tol)
  return(list("Score" = -ebic, "Pred" = 0))
}

ebic_eval_two_networks_BayesOpt <- function(n, R, A1, A2, beta0, beta1, beta2, ebic.gamma, edge.tol, tol){
   U <- exp(beta0 + beta1*A1 + beta2*A2)           #### remember a = beta1, b= beta0
   diag(U) <- 0
   try(ebic <- ebic_eval(n, R, U, ebic.gamma, edge.tol, tol))
   return(list("Score" = -ebic, "Pred" = 0))
}

standardise_network_matrix_tri <- function(A) {
  p <- nrow(A)
  A_tri <- A[upper.tri(A)]
  bar_A_tri <- mean(A_tri)
  S2_A_tri <- 1/length(A_tri)*sum((A_tri - bar_A_tri)^2)
  return((A - bar_A_tri)/sqrt(S2_A_tri))
}

## Turning the correlation matrix given by the golazo function back to a covariance matrix, useful in out-of-sample-llh
cor2cov <- function(Theta_cor, sigma2_vect){
  # Theta_cor is correlation matrix, sqrt(sigma2_vect) is the standard deviations of each variable
  p <- nrow(Theta_cor)
  Theta_cov <- matrix(NA, nrow = p, ncol = p)
  for(i in 1:p){
    Theta_cov[, i] <- Theta_cor[,i]*sqrt(sigma2_vect[i])*sqrt(sigma2_vect)   
  }
  return(Theta_cov)
}

threshold <- function(Rho_mat, threshold){
  return(Rho_mat*(abs(Rho_mat) >= threshold))
}

# No Network matrix
beta0_max_GLASSO <- function(R){
  return(log(max(abs(R - diag(diag(R))))))## check we can irgnore diags
  #return(log(max(max(diag(R)^2) - abs(R)))) ## Piotr's updated bound!
}


```

Hyparameters

```{r hyperparameters, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE}

ebic.gamma <- 0           # set to zero to get BIC
edge.tol <-  1e-6         # be consistent with GLASSO+EBIC method

```

Packages

```{r packages, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

library(golazo)
library(mvtnorm)
library(graphics)
#install.packages("NMOF")
library(NMOF)
library(rBayesianOptimization)
library(PerformanceAnalytics)
library(PortfolioAnalytics)

```

GLASSO

```{r GLASSO_run, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE}

N <- length(Y_repeats) #number of years

p <- vector() 
for (k in 1:N){
  p[k] <- ncol(Y_repeats[[k]]) #every year we have a different number of stocks (portfolio changes)
}

L <- list()
U <- list()
for (k in 1:N){
  L[[k]] <- matrix(-1,p[k],p[k])    #N matrices with different dimensions
  U[[k]] <- matrix (1,p[k],p[k])
  diag(U[[k]]) <- diag(L[[k]]) <- 0
}

beta0_grid_length <-10
beta0_grid_min <- -3
beta0_grid_max <- rep(NA,N)
beta0_GLASSO <- rep(NA,N)
beta_optimise <- list()

ebic_eval_optim_GLASSO_unstandarised <- rep(NA, N)

R <- list()
GraphicalModel <- list()
Rho_hat_GLASSO <- list()

#to delete some of the observations that make the model think there is positive correlation between BRISTOL.MYERS_SQUIBB_CO and COCA.COLA_CO
#Y_repeats[[1]]$BRISTOL.MYERS_SQUIBB_CO[Y_repeats[[1]]$BRISTOL.MYERS_SQUIBB_CO>4.3]<-0
#Y_repeats[[1]]$BRISTOL.MYERS_SQUIBB_CO[Y_repeats[[1]]$BRISTOL.MYERS_SQUIBB_CO<(-2.8)]<-0
#Y_repeats[[1]]$COCA.COLA_CO[Y_repeats[[1]]$COCA.COLA_CO>2.5] <- 0

time_GLASSO_freq.start <- Sys.time()
for(k in 1:N){
  
  n = nrow(Y_repeats[[k]])
  #### Estimating lambda ####
  R[[k]] <- stats::cov2cor(cov(Y_repeats[[k]]))  
  
  ## grid-search ##
  beta0_grid_max[k] <- beta0_max_GLASSO(R[[k]])
  
  #### BayesOpt ####
  beta_optimise[[k]] <- BayesianOptimization(
    FUN = function(beta0){ebic_eval_BayesOpt(n, R[[k]], beta0, ebic.gamma = ebic.gamma, edge.tol = edge.tol, tol = 1e-6)},
    bounds = list(beta0 = c(beta0_grid_min, beta0_grid_max[k])),
    init_points = 5,
    n_iter = beta0_grid_length - 5,
    acq = "ucb", 
    kernel = list(type = "exponential", power = 2),
  )

  beta0_GLASSO[k] <- beta_optimise[[k]]$Best_Par
   
  #### Using the optimal beta0 ##
  GraphicalModel[[k]] <- golazo (R[[k]], L = exp(beta0_GLASSO[k]) * L[[k]], U =exp(beta0_GLASSO[k])* U[[k]], tol = 1e-6, verbose=FALSE)

  ebic_eval_optim_GLASSO_unstandarised[k] <- ebic_eval_GLASSO_unstandarised(Y = as.matrix(Y_repeats[[k]]), res = GraphicalModel[[k]], n, beta0_GLASSO[[k]], ebic.gamma = ebic.gamma, edge.tol = edge.tol, tol = 1e-6)

  
  Rho_hat_GLASSO[[k]] <- threshold(cov2cor(GraphicalModel[[k]]$K), edge.tol)

}

time_GLASSO_freq.end <- Sys.time()

```

Analysis

```{r Analysis, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

beta0_GLASSO 

ebic_eval_optim_GLASSO_unstandarised

n_edges<-rep(NA,N)
for (k in 1:N){
  n_edges[k]<-sum(Rho_hat_GLASSO[[k]][lower.tri((Rho_hat_GLASSO[[k]]))] != 0)
}

time_GLASSO_freq1 <- time_GLASSO_freq.end - time_GLASSO_freq.start
time_GLASSO_freq <- round(time_GLASSO_freq1/N, 3)
time_GLASSO_freq

```

Minimum Variance function

```{r Minimum-Variance functions, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

minimum_variance_portfolio <- function (cov.Rt){
  one.vec <- rep(1,nrow(cov.Rt))
  num <- solve(cov.Rt) %*% one.vec
  den <- as.numeric(t(one.vec) %*% num)
  return(num/den)
}

```

Expected return function

```{r Expected Return function, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

expected_return_portfolio_minimum_variance <- function (cov.Rt, mean){
  one.vec <- rep(1,nrow(cov.Rt))
  num <- as.numeric(t(one.vec) %*% solve(cov.Rt) %*% mean)
  den <- as.numeric(t(one.vec) %*% solve(cov.Rt) %*% one.vec)
  return(num/den)
}

```

Defining baseline (equally weighted stocks)

```{r Defining baseline, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

mean <- list()
for (k in 1:N){
  mean[[k]] <- colMeans(Y_repeats[[k]])
}

weights_b <- list()
for (k in 1:N){
  weights_b[[k]] <- rep(1/p[k],p[k])
}

#the baseline is the target return rate for the mean variance portfolio  
baseline_portfolio <- rep(NA,N)   
for (k in 1:N){
  baseline_portfolio[k] <- sum(mean[[k]] %*% weights_b[[k]])
}

```

##Estimating Sigma with GLASSO

```{r estimating Sigma with GLASSO, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

Sigma_hat_GLASSO <- list()   #N pxp matrices where p changes according to the year
for (k in 1:N){
  Sigma_hat_GLASSO[[k]] <- cor2cov(Rho_hat_GLASSO[[k]], sigma2_vect = diag(cov(Y_repeats[[k]])))
}

```

Estimating weights

```{r Weights, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#minimum variance
weights_minimum_variance_GLASSO <- list()
for (k in 1:N){
  weights_minimum_variance_GLASSO[[k]] <- minimum_variance_portfolio(Sigma_hat_GLASSO[[k]]) 
}

for (k in 1:N){
  weights_minimum_variance_GLASSO[[k]] <- weights_minimum_variance_GLASSO[[k]]/sum(weights_minimum_variance_GLASSO[[k]])
}

#mean variance
weights_mean_variance_GLASSO <- list()
for (k in 1:N){
  weights_mean_variance_GLASSO[[k]] <- mvPortfolio(mean[[k]], Sigma_hat_GLASSO[[k]], min.return=baseline_portfolio[k])
}

```

Estimating expected return portfolio

```{r Expected return portfolio, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#minimum variance
expected_return_portfolio_minimum_variance_GLASSO <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_minimum_variance_GLASSO[k] <- expected_return_portfolio_minimum_variance(Sigma_hat_GLASSO[[k]], mean[[k]])
}

#mean variance
expected_return_portfolio_mean_variance_GLASSO <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_mean_variance_GLASSO[k] <- sum(weights_mean_variance_GLASSO[[k]]*mean[[k]])
}

```

Two portfolio solution

```{r Two portfolio solution, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#it makes the expected return portfolio equal to the baseline we defined before 

W_mk <- list()
for (k in 1:N){
  one.vec <- rep(1,nrow(Sigma_hat_GLASSO[[k]]))
  W_mk[[k]] <- (mean[[k]]%*%solve(Sigma_hat_GLASSO[[k]]))/(as.numeric(t(one.vec[k]) %*% mean[[k]] %*% solve(Sigma_hat_GLASSO[[k]])))
}

v_2PS_GLASSO <- list()
for (k in 1:N){
  v_2PS_GLASSO[[k]] <- weights_mean_variance_GLASSO[[k]]-weights_minimum_variance_GLASSO[[k]]
}

alpha_2PS_GLASSO <- rep(NA,N)
for (k in 1:N){
  alpha_2PS_GLASSO[k] <- ((sum(mean[[k]])/p[k])-(t(mean[[k]]) %*% weights_minimum_variance_GLASSO[[k]]))/(t(mean[[k]]) %*% v_2PS_GLASSO[[k]])
}

w_2PS_GLASSO <- list()
for (k in 1:N){
  w_2PS_GLASSO[[k]] <- weights_minimum_variance_GLASSO[[k]]+(v_2PS_GLASSO[[k]]*alpha_2PS_GLASSO[k])
}

expected_return_portfolio_2PS_GLASSO <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_2PS_GLASSO[k] <- t(mean[[k]])%*%w_2PS_GLASSO[[k]]
}

```

Plot Sigma and Rho matrices

```{r Plot Sigma matrix, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#function
matrixplot = function(m) {
  require(ggplot2)
  require(reshape2)
  
  p = nrow(m)
  
  m.mat = data.frame(Var1=rep(1:p,p),
                     Var2=rep(1:p,each=p),
                     Theta=as.vector(t(m)[,p:1]))
  
  pl = ggplot() + 
    geom_tile(data = m.mat, aes(x=Var1, y=as.numeric(Var2), fill=Theta)) + ylab('') + xlab('') +
    scale_fill_gradient2(low="red",high="blue",mid="white",midpoint=0) +
    geom_rect(aes(ymin=0.5,ymax=p+0.5,xmin=0.5,xmax=p+0.5),col="black",fill=NA,linetype='dashed') +
    theme(panel.grid = element_blank(), 
          panel.background = element_rect(fill='white'),
          plot.background = element_rect(color=NA), 
          axis.title.x=element_blank(), 
          axis.title.y=element_blank(),
          axis.ticks=element_blank(),
          axis.text=element_blank(),
          text = element_text(size=20), 
          legend.position = "right") 
  
  plot(pl)
}

#plots
for (k in 1:N){
  matrixplot(Sigma_hat_GLASSO[[k]]-diag(NA,p[k]))
  matrixplot(Rho_hat_GLASSO[[k]]-diag(NA,p[k]))
}

```

##Estimating Sigma as the sample covariance matrix

```{r Estimating Sigma as the sample covariance matrix, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

Sigma_hat_sample_covariance_matrix <- list()
for (k in 1:N){
  Sigma_hat_sample_covariance_matrix[[k]] <- cov(Y_repeats[[k]])
}

```

Estimating weights

```{r Weights, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#minimum variance
weights_minimum_variance_sample_covariance_matrix <- list()
for (k in 1:N){
  weights_minimum_variance_sample_covariance_matrix[[k]] <- minimum_variance_portfolio(Sigma_hat_sample_covariance_matrix[[k]]) 
}

#mean variance
weights_mean_variance_sample_covariance_matrix <- list()
for (k in 1:N){
  weights_mean_variance_sample_covariance_matrix[[k]] <- mvPortfolio(mean[[k]], Sigma_hat_sample_covariance_matrix[[k]], min.return=baseline_portfolio[k])
}

```

Estimating expected return portfolio

```{r Expected return portfolio, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#minimum variance
expected_return_portfolio_minimum_variance_sample_covariance_matrix <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_minimum_variance_sample_covariance_matrix[k] <- expected_return_portfolio_minimum_variance(Sigma_hat_sample_covariance_matrix[[k]], mean[[k]])
}

#mean variance
expected_return_portfolio_mean_variance_sample_covariance_matrix <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_mean_variance_sample_covariance_matrix[k] <- sum(weights_mean_variance_sample_covariance_matrix[[k]]*mean[[k]])
}

```

Two portfolio solution

```{r Two portfolio solution, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#it makes the expected return portfolio equal to the baseline we defined before 
W_mk <- list()
for (k in 1:N){
  one.vec <- rep(1,nrow(Sigma_hat_sample_covariance_matrix[[k]]))
  W_mk[[k]] <- (mean[[k]]%*%solve(Sigma_hat_sample_covariance_matrix[[k]]))/(as.numeric(t(one.vec[k]) %*% mean[[k]] %*% solve(Sigma_hat_sample_covariance_matrix[[k]])))
}

v_2PS_sample_covariance_matrix <- list()
for (k in 1:N){
  v_2PS_sample_covariance_matrix[[k]] <- weights_mean_variance_sample_covariance_matrix[[k]]-weights_minimum_variance_sample_covariance_matrix[[k]]
}

alpha_2PS_sample_covariance_matrix <- rep(NA,N)
for (k in 1:N){
  alpha_2PS_sample_covariance_matrix[k] <- ((sum(mean[[k]])/p[k])-(t(mean[[k]]) %*% weights_minimum_variance_sample_covariance_matrix[[k]]))/(t(mean[[k]]) %*% v_2PS_sample_covariance_matrix[[k]])
}

w_2PS_sample_covariance_matrix <- list()
for (k in 1:N){
  w_2PS_sample_covariance_matrix[[k]] <- weights_minimum_variance_sample_covariance_matrix[[k]]+(v_2PS_sample_covariance_matrix[[k]]*alpha_2PS_sample_covariance_matrix[k])
}

expected_return_portfolio_2PS_sample_covariance_matrix <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_2PS_sample_covariance_matrix[k] <- t(mean[[k]])%*%w_2PS_sample_covariance_matrix[[k]]
}

```

Plot Sigma matrix

```{r Plot Sigma matrix, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

for (k in 1:N){
  matrixplot(Sigma_hat_sample_covariance_matrix[[k]]-diag(NA,p[k]))
}

```

#Portfolio with no-short-sale (weights have to be nonnegative)

Estimating weights

```{r Weights no-short-sale, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#minimum variance
weights_minimum_variance_sample_covariance_matrix_jm <- list()
for (k in 1:N){
  weights_minimum_variance_sample_covariance_matrix_jm[[k]] <- minimum_variance_portfolio(Sigma_hat_sample_covariance_matrix[[k]]) 
}

#truncate weights
for (k in 1:N){
  for (i in 1:p[k]){
    if(weights_minimum_variance_sample_covariance_matrix_jm[[k]][[i]]>1.5){
      weights_minimum_variance_sample_covariance_matrix_jm[[k]][[i]]=1.5
    }
  }}

for (k in 1:N){
  for (i in 1:p[k]){
    if(weights_minimum_variance_sample_covariance_matrix_jm[[k]][[i]]<0){
      weights_minimum_variance_sample_covariance_matrix_jm[[k]][[i]]=0
    }
  }}

for (k in 1:N){
  weights_minimum_variance_sample_covariance_matrix_jm[[k]] <- weights_minimum_variance_sample_covariance_matrix_jm[[k]]/sum(weights_minimum_variance_sample_covariance_matrix_jm[[k]])
}

#mean variance
weights_mean_variance_sample_covariance_matrix_jm <- list()
for (k in 1:N){
  weights_mean_variance_sample_covariance_matrix_jm[[k]] <- mvPortfolio(mean[[k]], Sigma_hat_sample_covariance_matrix[[k]], min.return=baseline_portfolio[k])
}

#truncate weights
for (k in 1:N){
  for (i in 1:p[k]){
    if(weights_mean_variance_sample_covariance_matrix_jm[[k]][[i]]>1.5){
      weights_mean_variance_sample_covariance_matrix_jm[[k]][[i]]=1.5
    }
  }}

for (k in 1:N){
  for (i in 1:p[k]){
    if(weights_mean_variance_sample_covariance_matrix_jm[[k]][[i]]<0){
      weights_mean_variance_sample_covariance_matrix_jm[[k]][[i]]=0
    }
  }}

for (k in 1:N){
  weights_mean_variance_sample_covariance_matrix_jm[[k]] <- weights_mean_variance_sample_covariance_matrix_jm[[k]]/sum(weights_mean_variance_sample_covariance_matrix_jm[[k]])
}

```

##Estimating Sigma under independence assumption

```{r Estimating Sigma under independence assumption, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

Sigma_hat_diagonal <- list()
for (k in 1:N){
  Sigma_hat_diagonal[[k]] <- diag(diag(cov(Y_repeats[[k]])))
}

```

Estimating weights

```{r Weights independence assumption, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#minimum variance
weights_minimum_variance_diagonal <- list()
for (k in 1:N){
  weights_minimum_variance_diagonal[[k]] <- minimum_variance_portfolio(Sigma_hat_diagonal[[k]]) 
}

for (k in 1:N){
  weights_minimum_variance_diagonal[[k]] <- weights_minimum_variance_diagonal[[k]]/sum(weights_minimum_variance_diagonal[[k]])
}

#mean variance
weights_mean_variance_diagonal <- list()
for (k in 1:N){
  weights_mean_variance_diagonal[[k]] <- mvPortfolio(mean[[k]], Sigma_hat_diagonal[[k]], min.return=baseline_portfolio[k])
}

```

Estimating expected return portfolio

```{r Expected return portfolio, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#minimum variance
expected_return_portfolio_minimum_variance_diagonal <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_minimum_variance_diagonal[k] <- expected_return_portfolio_minimum_variance(Sigma_hat_diagonal[[k]], mean[[k]])
}

#mean variance
expected_return_portfolio_mean_variance_diagonal <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_mean_variance_diagonal[k] <- sum(weights_mean_variance_diagonal[[k]]*mean[[k]])
}

```

Two portfolio solution

```{r Two portfolio solution, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#it makes the expected return portfolio equal to the baseline we defined before 
W_mk <- list()
for (k in 1:N){
  one.vec <- rep(1,nrow(Sigma_hat_diagonal[[k]]))
  W_mk[[k]] <- (mean[[k]]%*%solve(Sigma_hat_diagonal[[k]]))/(as.numeric(t(one.vec[k]) %*% mean[[k]] %*% solve(Sigma_hat_diagonal[[k]])))
}

v_2PS_diagonal <- list()
for (k in 1:N){
  v_2PS_diagonal[[k]] <- weights_mean_variance_diagonal[[k]]-weights_minimum_variance_diagonal[[k]]
}

alpha_2PS_diagonal <- rep(NA,N)
for (k in 1:N){
  alpha_2PS_diagonal[k] <- ((sum(mean[[k]])/p[k])-(t(mean[[k]]) %*% weights_minimum_variance_diagonal[[k]]))/(t(mean[[k]]) %*% v_2PS_diagonal[[k]])
}

w_2PS_diagonal <- list()
for (k in 1:N){
  w_2PS_diagonal[[k]] <- weights_minimum_variance_diagonal[[k]]+(v_2PS_diagonal[[k]]*alpha_2PS_diagonal[k])
}

expected_return_portfolio_2PS_diagonal <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_2PS_diagonal[k] <- t(mean[[k]])%*%w_2PS_diagonal[[k]]
}

```

Loading Fama and French data 

```{r loading Fama and French data}

FF <- read.delim2('F-F_Research_Data_Factors_daily.txt',dec='.')

data_FF <- FF[FF$Year %in% (start_year:end_year),]

FF_repeats = list()
it = 0
for (t in start_year:end_year) {
  it = it+1
  FF_year = data_FF[data_FF$Year == t,-(1:2)]
  FF_repeats[[it]] = FF_year
}

```

Fitting Fama and French regression model and getting fitted values

```{r Fitting Fama and French model}

FF_regression <- list()
fitted_FF <- list()

for (k in 1:N){
  Y_year = Y_repeats[[k]]
  n<-nrow(Y_year)
  fitted_FF[[k]] = matrix(NA,n,p[k])
  for (i in 1:p[k])  {
    fitted_FF[[k]][,i] <- lm((Y_year[,i]-FF_repeats[[k]][[4]])~FF_repeats[[k]][[2]]+FF_repeats[[k]][[3]]+FF_repeats[[k]][[1]])$fitted
  }
  FF_regression[[k]] = fitted_FF[[k]]
}

```

Daily excess returns (residuals of the regression)

```{r Daily excess returns }

Y_repeats_FF<-list()
for (k in 1:N){
  for (i in 1:p[k]) {
    Y_repeats_FF[[k]] <- Y_repeats[[k]]-FF_regression[[k]][,i]
  }
}

```

GLASSO FF

```{r GLASSO_FF_run, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE}

N<-length(Y_repeats_FF) #number of years

p<-vector()
for (k in 1:N){
  p[k]<-ncol(Y_repeats_FF[[k]])
}

L<-list()
U<-list()
for (k in 1:N){
  L[[k]] <- matrix(-1,p[k],p[k])    
  U[[k]] <- matrix (1,p[k],p[k])
  diag(U[[k]]) <- diag(L[[k]]) <- 0
}

beta0_grid_length <-10
beta0_grid_min <- -3
beta_optimise <- list()
beta0_grid_max<-rep(NA,N)
beta0_GLASSO_FF<-rep(NA,N)

ebic_eval_optim_GLASSO_unstandarised_FF <- rep(NA, N)
R<-list()
GraphicalModel<-list()
Rho_hat_GLASSO_FF<-list()

time_GLASSO_freq.start <- Sys.time()
for(k in 1:N){
  
  n = nrow(Y_repeats_FF[[k]])
  #### Estimating lambda ####
  R[[k]] <- stats::cov2cor(cov(Y_repeats_FF[[k]]))  
  
  ## grid-search ##
  beta0_grid_max[k] <- beta0_max_GLASSO(R[[k]])
 
  #### BayesOpt ####
  beta_optimise[[k]] <- BayesianOptimization(
    FUN = function(beta0){ebic_eval_BayesOpt(n, R[[k]], beta0, ebic.gamma = ebic.gamma, edge.tol = edge.tol, tol = 1e-6)},
    bounds = list(beta0 = c(beta0_grid_min, beta0_grid_max[k])),
    init_points = 5,
    n_iter = beta0_grid_length - 5,
    acq = "ucb", 
    kernel = list(type = "exponential", power = 2),
  )
  
  beta0_GLASSO_FF[k] <- beta_optimise[[k]]$Best_Par
  
  #### Using the optimal beta0 ##
  GraphicalModel[[k]] <- golazo (R[[k]], L = exp(beta0_GLASSO_FF[k]) * L[[k]], U =exp(beta0_GLASSO_FF[k])* U[[k]], tol = 1e-6, verbose=FALSE)
  
  ebic_eval_optim_GLASSO_unstandarised_FF[k] <- ebic_eval_GLASSO_unstandarised(Y = as.matrix(Y_repeats_FF[[k]]), res = GraphicalModel[[k]], n, beta0_GLASSO_FF[[k]], ebic.gamma = ebic.gamma, edge.tol = edge.tol, tol = 1e-6)
  
  Rho_hat_GLASSO_FF[[k]] <- threshold(cov2cor(GraphicalModel[[k]]$K), edge.tol)
  
}
time_GLASSO_freq.end <- Sys.time()

```

Analysis

```{r Analysis, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

beta0_GLASSO_FF 

ebic_eval_optim_GLASSO_unstandarised_FF

n_edges<-rep(NA,N)
for (k in 1:N){
  n_edges[k] <- sum(Rho_hat_GLASSO_FF[[k]][lower.tri((Rho_hat_GLASSO_FF[[k]]))] != 0)
}

time_GLASSO_freq1 <- time_GLASSO_freq.end - time_GLASSO_freq.start
time_GLASSO_freq <- round(time_GLASSO_freq1/N, 3)
time_GLASSO_freq

```

Defining baseline (equally weighted stocks)

```{r Defining baseline, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

mean<-list()
for (k in 1:N){
  mean[[k]] <- colMeans(Y_repeats_FF[[k]])
}

weights_b <- list()
for (k in 1:N){
  weights_b[[k]] <- rep(1/p[k],p[k])
}

#the baseline is the target return rate for the mean variance portfolio  
baseline_portfolio<-rep(NA,N)   
for (k in 1:N){
  baseline_portfolio[k] <- sum(mean[[k]] %*% weights_b[[k]])
}

```

##Estimating Sigma with GLASSO FF

```{r estimating Sigma with GLASSO FF, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

Sigma_hat_GLASSO_FF <- list()
for (k in 1:N){
  Sigma_hat_GLASSO_FF[[k]] <- cor2cov(Rho_hat_GLASSO_FF[[k]], sigma2_vect = diag(cov(Y_repeats_FF[[k]])))
}

```

Estimating weights

```{r Weights, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#minimum variance
weights_minimum_variance_GLASSO_FF <- list()
for (k in 1:N){
  weights_minimum_variance_GLASSO_FF[[k]] <- minimum_variance_portfolio(Sigma_hat_GLASSO_FF[[k]]) 
}

for (k in 1:N){
  weights_minimum_variance_GLASSO_FF[[k]] <- weights_minimum_variance_GLASSO_FF[[k]]/sum(weights_minimum_variance_GLASSO_FF[[k]])
}

#mean variance
weights_mean_variance_GLASSO_FF <- list()
for (k in 1:N){
  weights_mean_variance_GLASSO_FF[[k]] <- mvPortfolio(mean[[k]], Sigma_hat_GLASSO_FF[[k]], min.return=baseline_portfolio[k])
}

```

Estimating expected return portfolio

```{r Expected return portfolio, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#minimum variance
expected_return_portfolio_minimum_variance_GLASSO_FF <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_minimum_variance_GLASSO_FF[k] <- expected_return_portfolio_minimum_variance(Sigma_hat_GLASSO_FF[[k]], mean[[k]])
}

#mean variance
expected_return_portfolio_mean_variance_GLASSO_FF <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_mean_variance_GLASSO_FF[k] <- sum(weights_mean_variance_GLASSO_FF[[k]]*mean[[k]])
}

```

Two portfolio solution

```{r Two portfolio solution, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#it makes the expected return portfolio equal to the baseline we defined before 

W_mk <- list()
for (k in 1:N){
  one.vec <- rep(1,nrow(Sigma_hat_GLASSO_FF[[k]]))
  W_mk[[k]] <- (mean[[k]]%*%solve(Sigma_hat_GLASSO_FF[[k]]))/(as.numeric(t(one.vec[k]) %*% mean[[k]] %*% solve(Sigma_hat_GLASSO_FF[[k]])))
}

v_2PS_GLASSO_FF <- list()
for (k in 1:N){
  v_2PS_GLASSO_FF[[k]] <- weights_mean_variance_GLASSO_FF[[k]]-weights_minimum_variance_GLASSO_FF[[k]]
}

alpha_2PS_GLASSO_FF <- rep(NA,N)
for (k in 1:N){
  alpha_2PS_GLASSO_FF[k] <- ((sum(mean[[k]])/p[k])-(t(mean[[k]]) %*% weights_minimum_variance_GLASSO_FF[[k]]))/(t(mean[[k]]) %*% v_2PS_GLASSO_FF[[k]])
}

w_2PS_GLASSO_FF <- list()
for (k in 1:N){
  w_2PS_GLASSO_FF[[k]] <- weights_minimum_variance_GLASSO_FF[[k]]+(v_2PS_GLASSO_FF[[k]]*alpha_2PS_GLASSO_FF[k])
}

expected_return_portfolio_2PS_GLASSO_FF <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_2PS_GLASSO_FF[k] <- t(mean[[k]])%*%w_2PS_GLASSO_FF[[k]]
}

```

Plot Sigma and Rho matrices

```{r Plot Sigma and Rho matrices, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

for (k in 1:N){
  matrixplot(Sigma_hat_GLASSO_FF[[k]]-diag(NA,p[k]))
  matrixplot(Rho_hat_GLASSO_FF[[k]]-diag(NA,p[k]))
}

```

#Principal Component Analysis 

```{r PCA}

Y_repeats_scaled <- list()
corr_matrix <- list()
for(k in 1:N){
  Y_repeats_scaled[[k]] <- scale(Y_repeats[[k]])
  corr_matrix[[k]] <- cor(Y_repeats_scaled[[k]])
}

data.pca <- list()
eigen_vector_matrix <- list()
eigen_values_matrix <- list()
for(k in 1:N){
  data.pca[[k]] <- eigen(corr_matrix[[k]])
  eigen_vector_matrix[[k]] <- data.pca[[k]]$vectors
  eigen_values_matrix[[k]] <- as.matrix(diag(data.pca[[k]]$values))
}

n_comp<-vector()
for (k in 1:N){
  n_comp[k] <- min(which(cumsum(diag(eigen_values_matrix[[k]]))/sum(diag(eigen_values_matrix[[k]])) > 0.90))
}

```

Function 

```{r PCA}

## Function that takes a correlation matrix and turns it into a covariance matrix with diagonal elements sigms2_vect - we need this function as factanal outputs a correlation matrix and we want a covariance matrix
cor2cov <- function(Theta_cor, sigma2_vect){
  # Theta_cor is correlation matrix, sqrt(sigma2_vect) is the standard deviations of each variable
  p <- nrow(Theta_cor)
  Theta_cov <- matrix(NA, nrow = p, ncol = p)
  for(i in 1:p){
    Theta_cov[, i] <- Theta_cor[,i]*sqrt(sigma2_vect[i])*sqrt(sigma2_vect)  
  }
  return(Theta_cov)
}

```

Estimating Sigma

```{r PCA}

fa_X <- list()
for (k in 1:N){
  fa_X[[k]] <- factanal(Y_repeats[[k]], factors = n_comp[k], start = eigen_vector_matrix[[k]][,1:n_comp[k]])
}

## factanal outputs a correlation matrix so we need to transform this back into a covariance matrix before we invert
Sigma_hat_PCA <- list()
for (k in 1:N){
  Sigma_hat_PCA[[k]] <- cor2cov(fa_X[[k]]$loadings%*%t(fa_X[[k]]$loadings)+diag(fa_X[[k]]$uniquenesses), diag(Sigma_hat_sample_covariance_matrix[[k]]))
  Sigma_hat_PCA[[k]]<-solve(Sigma_hat_PCA[[k]]) 
}

```

Estimating weights

```{r Weights, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#minimum variance
weights_minimum_variance_PCA <- list()
for (k in 1:N){
  weights_minimum_variance_PCA[[k]] <- minimum_variance_portfolio(Sigma_hat_PCA[[k]]) 
}

for (k in 1:N){
  weights_minimum_variance_PCA[[k]] <- weights_minimum_variance_PCA[[k]]/sum(weights_minimum_variance_PCA[[k]])
}

#mean variance
weights_mean_variance_PCA <-list()
for (k in 1:N){
  weights_mean_variance_PCA[[k]] <- mvPortfolio(mean[[k]], Sigma_hat_PCA[[k]], min.return=baseline_portfolio[k])
}

```

Estimating expected return portfolio

```{r Expected return portfolio, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#minimum variance
expected_return_portfolio_minimum_variance_PCA <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_minimum_variance_PCA[k] <- expected_return_portfolio_minimum_variance(Sigma_hat_PCA[[k]], mean[[k]])
}

#mean variance
expected_return_portfolio_mean_variance_PCA <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_mean_variance_PCA[k] <- sum(weights_mean_variance_PCA[[k]]*mean[[k]])
}

```

Two portfolio solution

```{r Two portfolio solution, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

#it makes the expected return portfolio equal to the baseline we defined before 

W_mk <- list()
for (k in 1:N){
  one.vec <- rep(1,nrow(Sigma_hat_PCA[[k]]))
  W_mk[[k]] <- (mean[[k]]%*%solve(Sigma_hat_PCA[[k]]))/(as.numeric(t(one.vec[k]) %*% mean[[k]] %*% solve(Sigma_hat_PCA[[k]])))
}

v_2PS_PCA <- list()
for (k in 1:N){
  v_2PS_PCA[[k]] <- weights_mean_variance_PCA[[k]]-weights_minimum_variance_PCA[[k]]
}

alpha_2PS_PCA <- rep(NA,N)
for (k in 1:N){
  alpha_2PS_PCA[k] <- ((sum(mean[[k]])/p[k])-(t(mean[[k]]) %*% weights_minimum_variance_PCA[[k]]))/(t(mean[[k]]) %*% v_2PS_PCA[[k]])
}

w_2PS_PCA <- list()
for (k in 1:N){
  w_2PS_PCA[[k]] <- weights_minimum_variance_PCA[[k]]+(v_2PS_PCA[[k]]*alpha_2PS_PCA[k])
}

expected_return_portfolio_2PS_PCA <- rep(NA,N)
for (k in 1:N){
  expected_return_portfolio_2PS_PCA[k] <- t(mean[[k]])%*%w_2PS_PCA[[k]]
}

```

Plot Sigma and Rho matrices

```{r Plot Sigma and Rho matrices, include=TRUE,echo=TRUE, eval=TRUE,cache=FALSE}

for (k in 1:N){
  matrixplot(Sigma_hat_PCA[[k]]-diag(NA,p[k]))
}

```

#Actual portfolio return rate

Loading data years after

```{r Loading data years after}

start_year = 1986  #start_year we had before + 1
end_year = 2016    #end_year we had before + 1

Y_repeats_actual = list()
Y_prova = list()
k <- seq(from=1, to=length(j), by=1)
t <- seq(from=start_year, to=end_year, by=1)
for (k in 1:N){
  Y_prova[[k]] <- Y[[k]][Y[[k]]$Year == t[k],-2]  #time series with the column 'dates'
  Y_repeats_actual[[k]] = Y[[k]][Y[[k]]$Year == t[k],-(1:2)]
} 
```

GLASSO

```{r Actual portfolio return rate GLASSO}

r <- list()   #actual return rates of stocks per year
for (k in 1:N){
  r[[k]] <- colSums(Y_repeats_actual[[k]])
}

#minimum variance
portfolio_actual_return_rate_minimum_variance_GLASSO <- rep(NA,N)
for (k in 1:N){
  portfolio_actual_return_rate_minimum_variance_GLASSO[k] <- sum(weights_minimum_variance_GLASSO[[k]] * r[[k]])
}

#mean variance
portfolio_actual_return_rate_mean_variance_GLASSO <- rep(NA,N)
for (k in 1:N){
  portfolio_actual_return_rate_mean_variance_GLASSO[k] <- sum(weights_mean_variance_GLASSO[[k]] * r[[k]])
}

#cumulative actual portfolio return rate with minimum and mean variance 
sum(portfolio_actual_return_rate_minimum_variance_GLASSO)
sum(portfolio_actual_return_rate_mean_variance_GLASSO)

```

sample covariance matrix

```{r Actual portfolio return rate sample covariance matrix}

#minimum variance
portfolio_actual_return_rate_minimum_variance_sample_covariance_matrix <- rep(NA,N)
for (k in 1:N){
  portfolio_actual_return_rate_minimum_variance_sample_covariance_matrix[k] <- sum(weights_minimum_variance_sample_covariance_matrix[[k]] * r[[k]])
}

#mean variance
portfolio_actual_return_rate_mean_variance_sample_covariance_matrix <- rep(NA,N)
for (k in 1:N){
  portfolio_actual_return_rate_mean_variance_sample_covariance_matrix[k] <- sum(weights_mean_variance_sample_covariance_matrix[[k]] * r[[k]])
}

#cumulative actual portfolio return rate with minimum and mean variance 
sum(portfolio_actual_return_rate_minimum_variance_sample_covariance_matrix)
sum(portfolio_actual_return_rate_mean_variance_sample_covariance_matrix)

```

Diagonal matrix

```{r Actual portfolio return rate under independence}

#minimum variance
portfolio_actual_return_rate_minimum_variance_diagonal <- rep(NA,N)
for (k in 1:N){
  portfolio_actual_return_rate_minimum_variance_diagonal[k] <- sum(weights_minimum_variance_diagonal[[k]] * r[[k]])
}

#mean variance
portfolio_actual_return_rate_mean_variance_diagonal <- rep(NA,N)
for (k in 1:N){
  portfolio_actual_return_rate_mean_variance_diagonal[k] <- sum(weights_mean_variance_diagonal[[k]] * r[[k]])
}

#cumulative actual portfolio return rate with minimum and mean variance 
sum(portfolio_actual_return_rate_minimum_variance_diagonal)
sum(portfolio_actual_return_rate_mean_variance_diagonal)

```

GLASSO FF

```{r Actual portfolio return rate GLASSO FF}

#minimum variance
portfolio_actual_return_rate_minimum_variance_GLASSO_FF <- rep(NA,N)
for (k in 1:N){
  portfolio_actual_return_rate_minimum_variance_GLASSO_FF[k] <- sum(weights_minimum_variance_GLASSO_FF[[k]] * r[[k]])
}

#mean variance
portfolio_actual_return_rate_mean_variance_GLASSO_FF <- rep(NA,N)
for (k in 1:N){
  portfolio_actual_return_rate_mean_variance_GLASSO_FF[k] <- sum(weights_mean_variance_GLASSO_FF[[k]] * r[[k]])
}

#cumulative actual portfolio return rate with minimum and mean variance 
sum(portfolio_actual_return_rate_minimum_variance_GLASSO_FF)
sum(portfolio_actual_return_rate_mean_variance_GLASSO_FF)

```

PCA

```{r Actual portfolio return rate PCA}

#minimum variance
portfolio_actual_return_rate_minimum_variance_PCA <- rep(NA,N)
for (k in 1:N){
  portfolio_actual_return_rate_minimum_variance_PCA[k] <- sum(weights_minimum_variance_PCA[[k]] * r[[k]])
}

#mean variance
portfolio_actual_return_rate_mean_variance_PCA <- rep(NA,N)
for (k in 1:N){
  portfolio_actual_return_rate_mean_variance_PCA[k] <- sum(weights_mean_variance_PCA[[k]] * r[[k]])
}

#cumulative actual portfolio return rate with minimum and mean variance 
sum(portfolio_actual_return_rate_minimum_variance_PCA)
sum(portfolio_actual_return_rate_mean_variance_PCA)

```

Equally weighted portfolio 

```{r Equally weighted portfolio}

portfolio_actual_return_rate_equally_weighted_portfolio <- rep(NA,N)
for (k in 1:N){
  portfolio_actual_return_rate_equally_weighted_portfolio[k] <- sum(weights_b[[k]] * r[[k]])
}

#cumulative actual portfolio return rate 
sum(portfolio_actual_return_rate_equally_weighted_portfolio)

```

Portfolio with no-short-sale (weights have to be nonnegative)

```{r Portfolio with no-short-sale (weights have to be nonnegative) }

#minimum variance
portfolio_actual_return_rate_minimum_variance_sample_covariance_matrix_jm <- rep(NA,N)
for (k in 1:N){
  portfolio_actual_return_rate_minimum_variance_sample_covariance_matrix_jm[k] <- sum(weights_minimum_variance_sample_covariance_matrix_jm[[k]] * r[[k]])
}

#mean variance
portfolio_actual_return_rate_mean_variance_sample_covariance_matrix_jm <- rep(NA,N)
for (k in 1:N){
  portfolio_actual_return_rate_mean_variance_sample_covariance_matrix_jm[k] <- sum(weights_mean_variance_sample_covariance_matrix_jm[[k]] * r[[k]])
}

#cumulative actual portfolio return rate with minimum and mean variance 
sum(portfolio_actual_return_rate_minimum_variance_sample_covariance_matrix_jm)
sum(portfolio_actual_return_rate_mean_variance_sample_covariance_matrix_jm)

```

#Performance

Volatily

```{r Performance Volatily}

for (k in 1:N){
  row.names(Y_prova[[k]]) <- Y_prova[[k]][,1]
}

#minimum variance
daily_portfolio_return_minimum_variance_GLASSO <- list()
daily_portfolio_return_minimum_variance_sample_covariance_matrix <- list()
daily_portfolio_return_minimum_variance_diagonal <- list()
daily_portfolio_return_minimum_variance_PCA <- list()
daily_portfolio_return_equally_weighted_portfolio <- list()
daily_portfolio_return_minimum_variance_sample_covariance_matrix_jm <-list()
daily_portfolio_return_minimum_variance_GLASSO_FF <- list()

for (k in 1:31){
  daily_portfolio_return_minimum_variance_GLASSO[[k]] <- Return.portfolio(Y_prova[[k]][,2:(p[k]+1)],weights=unlist(weights_minimum_variance_GLASSO[k]), verbose=TRUE)
  
  daily_portfolio_return_minimum_variance_sample_covariance_matrix[[k]] <- Return.portfolio(Y_prova[[k]][,2:(p[k]+1)],weights=unlist(weights_minimum_variance_sample_covariance_matrix[k]), verbose=TRUE)
  
  daily_portfolio_return_minimum_variance_diagonal[[k]] <- Return.portfolio(Y_prova[[k]][,2:(p[k]+1)],weights=unlist(weights_minimum_variance_diagonal[k]), verbose=TRUE)
  
  daily_portfolio_return_minimum_variance_PCA[[k]] <- Return.portfolio(Y_prova[[k]][,2:(p[k]+1)],weights=unlist(weights_minimum_variance_PCA[k]), verbose=TRUE)
  
  daily_portfolio_return_equally_weighted_portfolio[[k]] <- Return.portfolio(Y_prova[[k]][,2:(p[k]+1)],weights=unlist(weights_b[k]), verbose=TRUE)
  
  daily_portfolio_return_minimum_variance_sample_covariance_matrix_jm[[k]] <- Return.portfolio(Y_prova[[k]][,2:(p[k]+1)],weights=unlist(weights_minimum_variance_sample_covariance_matrix_jm[k]), verbose=TRUE)
  
  daily_portfolio_return_minimum_variance_GLASSO_FF[[k]] <- Return.portfolio(Y_prova[[k]][,2:(p[k]+1)],weights=unlist(weights_minimum_variance_GLASSO_FF[k]), verbose=TRUE)
}

StdDev_minimum_variance_GLASSO <- vector()
StdDev_minimum_variance_sample_covariance_matrix <- vector()
StdDev_minimum_variance_diagonal <- vector()
StdDev_minimum_variance_PCA <- vector()
StdDev_equally_weighted_portfolio <- vector()
StdDev_minimum_variance_sample_covariance_matrix_jm <- vector()
StdDev_minimum_variance_GLASSO_FF <- vector()

for (k in 1:31){
  StdDev_minimum_variance_GLASSO[k] <- StdDev(daily_portfolio_return_minimum_variance_GLASSO[[k]]$returns)
  
  StdDev_minimum_variance_sample_covariance_matrix[k] <- StdDev(daily_portfolio_return_minimum_variance_sample_covariance_matrix[[k]]$returns)
  
  StdDev_minimum_variance_diagonal[k] <- StdDev(daily_portfolio_return_minimum_variance_diagonal[[k]]$returns)
  
  StdDev_minimum_variance_PCA[k] <- StdDev(daily_portfolio_return_minimum_variance_PCA[[k]]$returns)
  
  StdDev_equally_weighted_portfolio[k] <- StdDev(daily_portfolio_return_equally_weighted_portfolio[[k]]$returns)
  
  StdDev_minimum_variance_sample_covariance_matrix_jm[k] <- StdDev(daily_portfolio_return_minimum_variance_sample_covariance_matrix_jm[[k]]$returns)
  
  StdDev_minimum_variance_GLASSO_FF[k] <- StdDev(daily_portfolio_return_minimum_variance_GLASSO_FF[[k]]$returns)
}

mean(StdDev_minimum_variance_GLASSO)
mean(StdDev_minimum_variance_sample_covariance_matrix)
mean(StdDev_minimum_variance_diagonal)
mean(StdDev_minimum_variance_PCA)
mean(StdDev_equally_weighted_portfolio)
mean(StdDev_minimum_variance_sample_covariance_matrix_jm)
mean(StdDev_minimum_variance_GLASSO_FF)

#mean variance
daily_portfolio_return_mean_variance_GLASSO <- list()
daily_portfolio_return_mean_variance_sample_covariance_matrix <- list()
daily_portfolio_return_mean_variance_diagonal <- list()
daily_portfolio_return_mean_variance_PCA <- list()
daily_portfolio_return_mean_variance_sample_covariance_matrix_jm <- list()
daily_portfolio_return_mean_variance_GLASSO_FF <- list()

for (k in 1:31){
  daily_portfolio_return_mean_variance_GLASSO[[k]] <- Return.portfolio(Y_prova[[k]][,2:(p[k]+1)],weights=unlist(weights_mean_variance_GLASSO[k]), verbose=TRUE)
  
  daily_portfolio_return_mean_variance_sample_covariance_matrix[[k]] <- Return.portfolio(Y_prova[[k]][,2:(p[k]+1)],weights=unlist(weights_mean_variance_sample_covariance_matrix[k]), verbose=TRUE)
  
  daily_portfolio_return_mean_variance_diagonal[[k]] <- Return.portfolio(Y_prova[[k]][,2:(p[k]+1)],weights=unlist(weights_mean_variance_diagonal[k]), verbose=TRUE)
  
  daily_portfolio_return_mean_variance_PCA[[k]] <- Return.portfolio(Y_prova[[k]][,2:(p[k]+1)],weights=unlist(weights_mean_variance_PCA[k]), verbose=TRUE)
  
  daily_portfolio_return_mean_variance_sample_covariance_matrix_jm[[k]] <- Return.portfolio(Y_prova[[k]][,2:(p[k]+1)],weights=unlist(weights_mean_variance_sample_covariance_matrix_jm[k]), verbose=TRUE)
  
  daily_portfolio_return_mean_variance_GLASSO_FF[[k]] <- Return.portfolio(Y_prova[[k]][,2:(p[k]+1)],weights=unlist(weights_mean_variance_GLASSO_FF[k]), verbose=TRUE)
}

StdDev_mean_variance_GLASSO <- vector()
StdDev_mean_variance_sample_covariance_matrix <- vector()
StdDev_mean_variance_diagonal <- vector()
StdDev_mean_variance_PCA <- vector()
StdDev_mean_variance_sample_covariance_matrix_jm <- vector()
StdDev_mean_variance_GLASSO_FF <- vector()

for (k in 1:31){
  StdDev_mean_variance_GLASSO[k] <- StdDev(daily_portfolio_return_mean_variance_GLASSO[[k]]$returns)
  
  StdDev_mean_variance_sample_covariance_matrix[k] <- StdDev(daily_portfolio_return_mean_variance_sample_covariance_matrix[[k]]$returns)
   
  StdDev_mean_variance_diagonal[k] <- StdDev(daily_portfolio_return_mean_variance_diagonal[[k]]$returns)
  
  StdDev_mean_variance_PCA[k] <- StdDev(daily_portfolio_return_mean_variance_PCA[[k]]$returns)
  
  StdDev_mean_variance_sample_covariance_matrix_jm[k] <- StdDev(daily_portfolio_return_mean_variance_sample_covariance_matrix_jm[[k]]$returns)
  
  StdDev_mean_variance_GLASSO_FF[k] <- StdDev(daily_portfolio_return_mean_variance_GLASSO_FF[[k]]$returns)
}

mean(StdDev_mean_variance_GLASSO)
mean(StdDev_mean_variance_sample_covariance_matrix)
mean(StdDev_mean_variance_diagonal)
mean(StdDev_mean_variance_PCA)
mean(StdDev_mean_variance_sample_covariance_matrix_jm)
mean(StdDev_mean_variance_GLASSO_FF)

```

Sharpe Ratio

```{r Performance Sharpe Ratio}

#minimum variance
Sharpe_ratio_minimum_variance_GLASSO <- vector()
Sharpe_ratio_minimum_variance_sample_covariance_matrix <- vector()
Sharpe_ratio_minimum_variance_sample_covariance_matrix_jm <- vector()
Sharpe_ratio_minimum_variance_diagonal <- vector()
Sharpe_ratio_equally_weighted_portfolio <- vector()
Sharpe_ratio_minimum_variance_PCA <- vector()
Sharpe_ratio_minimum_variance_GLASSO_FF <- vector()

for (k in 1:N){
  row.names(Y_prova[[k]]) <- Y_prova[[k]][,1]
}

for (k in 1:N){
  Sharpe_ratio_minimum_variance_GLASSO[k] <- SharpeRatio((Y_prova[[k]][,2:(p[k]+1),drop=FALSE]), FUN= "StdDev", weights = unlist(weights_minimum_variance_GLASSO[k]))
  
  Sharpe_ratio_minimum_variance_sample_covariance_matrix[k] <- SharpeRatio((Y_prova[[k]][,2:(p[k]+1),drop=FALSE]), FUN= "StdDev", weights = unlist(weights_minimum_variance_sample_covariance_matrix[k]))
  
  Sharpe_ratio_minimum_variance_PCA[k] <- SharpeRatio((Y_prova[[k]][,2:(p[k]+1),drop=FALSE]), FUN= "StdDev", weights = unlist(weights_minimum_variance_PCA[k]))
  
  Sharpe_ratio_minimum_variance_diagonal[k] <- SharpeRatio((Y_prova[[k]][,2:(p[k]+1),drop=FALSE]), FUN= "StdDev", weights = unlist(weights_minimum_variance_diagonal[k]))
  
  Sharpe_ratio_minimum_variance_sample_covariance_matrix_jm[k] <- SharpeRatio((Y_prova[[k]][,2:(p[k]+1),drop=FALSE]), FUN= "StdDev", weights = unlist(weights_minimum_variance_sample_covariance_matrix_jm[k]))
  
  Sharpe_ratio_equally_weighted_portfolio[k] <- SharpeRatio((Y_prova[[k]][,2:(p[k]+1),drop=FALSE]), FUN= "StdDev", weights = unlist(weights_b[k]))
  
  Sharpe_ratio_minimum_variance_GLASSO_FF[k] <- SharpeRatio((Y_prova[[k]][,2:(p[k]+1),drop=FALSE]), FUN= "StdDev", weights = unlist(weights_minimum_variance_GLASSO_FF[k]))
}

mean(Sharpe_ratio_minimum_variance_GLASSO)
mean(Sharpe_ratio_minimum_variance_sample_covariance_matrix)
mean(Sharpe_ratio_minimum_variance_sample_covariance_matrix_jm)
mean(Sharpe_ratio_minimum_variance_diagonal)
mean(Sharpe_ratio_equally_weighted_portfolio)
mean(Sharpe_ratio_minimum_variance_PCA)
mean(Sharpe_ratio_minimum_variance_GLASSO_FF)

#mean variance
Sharpe_ratio_mean_variance_GLASSO <- vector()
Sharpe_ratio_mean_variance_sample_covariance_matrix <- vector()
Sharpe_ratio_mean_variance_sample_covariance_matrix_jm <- vector()
Sharpe_ratio_mean_variance_diagonal <- vector()
Sharpe_ratio_mean_variance_PCA < -vector()
Sharpe_ratio_mean_variance_GLASSO_FF <- vector()

for (k in 1:N){
  Sharpe_ratio_mean_variance_GLASSO[k] <- SharpeRatio((Y_prova[[k]][,2:(p[k]+1),drop=FALSE]), FUN= "StdDev", weights = unlist(weights_mean_variance_GLASSO[k]))
  
  Sharpe_ratio_mean_variance_sample_covariance_matrix[k] <- SharpeRatio((Y_prova[[k]][,2:(p[k]+1),drop=FALSE]), FUN= "StdDev", weights = unlist(weights_mean_variance_sample_covariance_matrix[k]))
  
  Sharpe_ratio_mean_variance_PCA[k] <- SharpeRatio((Y_prova[[k]][,2:(p[k]+1),drop=FALSE]), FUN= "StdDev", weights = unlist(weights_mean_variance_PCA[k]))
  
  Sharpe_ratio_mean_variance_diagonal[k] <- SharpeRatio((Y_prova[[k]][,2:(p[k]+1),drop=FALSE]), FUN= "StdDev", weights = unlist(weights_mean_variance_diagonal[k]))
  
  Sharpe_ratio_mean_variance_sample_covariance_matrix_jm[k] <- SharpeRatio((Y_prova[[k]][,2:(p[k]+1),drop=FALSE]), FUN= "StdDev", weights = unlist(weights_mean_variance_sample_covariance_matrix_jm[k]))
  
  Sharpe_ratio_mean_variance_GLASSO_FF[k] <- SharpeRatio((Y_prova[[k]][,2:(p[k]+1),drop=FALSE]), FUN= "StdDev", weights = unlist(weights_mean_variance_GLASSO_FF[k]))
}

mean((Sharpe_ratio_mean_variance_GLASSO))
mean(Sharpe_ratio_mean_variance_sample_covariance_matrix)
mean(Sharpe_ratio_mean_variance_sample_covariance_matrix_jm)
mean(Sharpe_ratio_mean_variance_diagonal)
mean(Sharpe_ratio_mean_variance_PCA)
mean(Sharpe_ratio_mean_variance_GLASSO_FF)

```

Herfindal Index

```{r Herfindal Index}

#minimum variance
HHI_minimum_variance_GLASSO <- vector()
HHI_minimum_variance_sample_covariance_matrix <- vector()
HHI_minimum_variance_sample_covariance_matrix_jm <- vector()
HHI_minimum_variance_diagonal <- vector()
HHI_minimum_variance_PCA <- vector()
HHI_equally_weighted_portfolio <- vector()
HHI_minimum_variance_GLASSO_FF <- vector()

for (k in 1:N){
  HHI_minimum_variance_GLASSO[k] <- HHI(unlist(weights_minimum_variance_GLASSO[[k]]))
  
  HHI_minimum_variance_sample_covariance_matrix[k] <- HHI(unlist(weights_minimum_variance_sample_covariance_matrix[[k]]))
  
  HHI_minimum_variance_sample_covariance_matrix_jm[k] <- HHI(unlist(weights_minimum_variance_sample_covariance_matrix_jm[[k]]))
  
  HHI_minimum_variance_diagonal[k] <- HHI(unlist(weights_minimum_variance_diagonal[[k]]))
  
  HHI_minimum_variance_PCA[k] <- HHI(unlist(weights_minimum_variance_PCA[[k]]))
  
  HHI_equally_weighted_portfolio[k] <- HHI(unlist(weights_b[[k]]))ù
  
  HHI_minimum_variance_GLASSO_FF[k] <- HHI(unlist(weights_minimum_variance_GLASSO_FF[[k]]))
}

mean(HHI_minimum_variance_GLASSO)
mean(HHI_minimum_variance_sample_covariance_matrix)
mean(HHI_minimum_variance_sample_covariance_matrix_jm)
mean(HHI_minimum_variance_diagonal)
mean(HHI_minimum_variance_PCA)
mean(HHI_equally_weighted_portfolio)
mean(HHI_minimum_variance_GLASSO_FF)

#mean variance
HHI_mean_variance_GLASSO <- vector()
HHI_mean_variance_sample_covariance_matrix <- vector()
HHI_mean_variance_sample_covariance_matrix_jm <- vector()
HHI_mean_variance_diagonal <- vector()
HHI_mean_variance_PCA <- vector()
HHI_mean_variance_GLASSO_FF <- vector()

for (k in 1:N){
  HHI_mean_variance_GLASSO[k] <- HHI(unlist(weights_mean_variance_GLASSO[[k]]))
  
  HHI_mean_variance_sample_covariance_matrix[k] <- HHI(unlist(weights_mean_variance_sample_covariance_matrix[[k]]))
  
  HHI_mean_variance_sample_covariance_matrix_jm[k] <- HHI(unlist(weights_mean_variance_sample_covariance_matrix_jm[[k]]))
  
  HHI_mean_variance_diagonal[k] <- HHI(unlist(weights_mean_variance_diagonal[[k]]))
  
  HHI_mean_variance_PCA[k] <- HHI(unlist(weights_mean_variance_PCA[[k]]))
  
  HHI_mean_variance_GLASSO_FF[k] <- HHI(unlist(weights_mean_variance_GLASSO_FF[[k]]))
}

mean(HHI_mean_variance_GLASSO)
mean(HHI_mean_variance_sample_covariance_matrix)
mean(HHI_mean_variance_sample_covariance_matrix_jm)
mean(HHI_mean_variance_diagonal)
mean(HHI_mean_variance_PCA)
mean(HHI_mean_variance_GLASSO_FF)

```
